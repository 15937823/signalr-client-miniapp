{"version":3,"file":"HttpConnection.js","sourceRoot":"","sources":["../../src/HttpConnection.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\nimport { HttpClient } from \"./HttpClient\";\nimport { IConnection } from \"./IConnection\";\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\nimport { ILogger, LogLevel } from \"./ILogger\";\nimport { HttpTransportType, ITransport, TransferFormat } from \"./ITransport\";\nimport { Arg, createLogger } from \"./Utils\";\nimport { WebSocketTransport } from \"./WebSocketTransport\";\n\n/** @private */\nconst enum ConnectionState {\n    Connecting,\n    Connected,\n    Disconnected,\n}\n\n/** @private */\nexport interface INegotiateResponse {\n    connectionId?: string;\n    availableTransports?: IAvailableTransport[];\n    url?: string;\n    accessToken?: string;\n    error?: string;\n}\n\n/** @private */\nexport interface IAvailableTransport {\n    transport: keyof typeof HttpTransportType;\n    transferFormats: Array<keyof typeof TransferFormat>;\n}\n\nconst MAX_REDIRECTS = 100;\n\n/** @private */\nexport class HttpConnection implements IConnection {\n    private connectionState: ConnectionState;\n    private baseUrl: string;\n    private readonly httpClient: HttpClient;\n    private readonly logger: ILogger;\n    private readonly options: IHttpConnectionOptions;\n    private transport?: ITransport;\n    private startPromise?: Promise<void>;\n    private stopError?: Error;\n    private accessTokenFactory?: () => string | Promise<string>;\n\n    public readonly features: any = {};\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\n    public onclose: ((e?: Error) => void) | null;\n\n    constructor(url: string, options: IHttpConnectionOptions = {}) {\n        Arg.isRequired(url, \"url\");\n\n        this.logger = createLogger(options.logger);\n        this.baseUrl = this.resolveUrl(url);\n\n        options = options || {};\n        options.logMessageContent = options.logMessageContent || false;\n\n        this.httpClient = options.httpClient || new DefaultHttpClient();\n        this.connectionState = ConnectionState.Disconnected;\n        this.options = options;\n        this.onreceive = null;\n        this.onclose = null;\n    }\n\n    public start(): Promise<void>;\n    public start(transferFormat: TransferFormat): Promise<void>;\n    public start(transferFormat?: TransferFormat): Promise<void> {\n        transferFormat = transferFormat || TransferFormat.Binary;\n\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n\n        this.logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\n\n        if (this.connectionState !== ConnectionState.Disconnected) {\n            return Promise.reject(new Error(\"Cannot start a connection that is not in the 'Disconnected' state.\"));\n        }\n\n        this.connectionState = ConnectionState.Connecting;\n\n        this.startPromise = this.startInternal(transferFormat);\n        return this.startPromise;\n    }\n\n    public send(data: string | ArrayBuffer): Promise<void> {\n        if (this.connectionState !== ConnectionState.Connected) {\n            throw new Error(\"Cannot send data if the connection is not in the 'Connected' State.\");\n        }\n\n        // Transport will not be null if state is connected\n        return this.transport!.send(data);\n    }\n\n    public async stop(error?: Error): Promise<void> {\n        this.connectionState = ConnectionState.Disconnected;\n        // Set error as soon as possible otherwise there is a race between\n        // the transport closing and providing an error and the error from a close message\n        // We would prefer the close message error.\n        this.stopError = error;\n\n        try {\n            await this.startPromise;\n        } catch (e) {\n            // this exception is returned to the user as a rejected Promise from the start method\n        }\n\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\n        if (this.transport) {\n            await this.transport.stop();\n            this.transport = undefined;\n        }\n    }\n\n    private async startInternal(transferFormat: TransferFormat): Promise<void> {\n        // Store the original base url and the access token factory since they may change\n        // as part of negotiating\n        let url = this.baseUrl;\n        this.accessTokenFactory = this.options.accessTokenFactory;\n\n        try {\n            if (this.options.skipNegotiation) {\n                if (this.options.transport === HttpTransportType.WebSockets) {\n                    // No need to add a connection ID in this case\n                    this.transport = this.constructTransport(HttpTransportType.WebSockets);\n                    // We should just call connect directly in this case.\n                    // No fallback or negotiate in this case.\n                    await this.transport!.connect(url, transferFormat);\n                } else {\n                    throw Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\n                }\n            } else {\n                let negotiateResponse: INegotiateResponse | null = null;\n                let redirects = 0;\n\n                do {\n                    negotiateResponse = await this.getNegotiationResponse(url);\n                    // the user tries to stop the connection when it is being started\n                    if (this.connectionState === ConnectionState.Disconnected) {\n                        return;\n                    }\n\n                    if (negotiateResponse.error) {\n                        throw Error(negotiateResponse.error);\n                    }\n\n                    if ((negotiateResponse as any).ProtocolVersion) {\n                        throw Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\n                    }\n\n                    if (negotiateResponse.url) {\n                        url = negotiateResponse.url;\n                    }\n\n                    if (negotiateResponse.accessToken) {\n                        // Replace the current access token factory with one that uses\n                        // the returned access token\n                        const accessToken = negotiateResponse.accessToken;\n                        this.accessTokenFactory = () => accessToken;\n                    }\n\n                    redirects++;\n                }\n                while (negotiateResponse.url && redirects < MAX_REDIRECTS);\n\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\n                    throw Error(\"Negotiate redirection limit exceeded.\");\n                }\n\n                await this.createTransport(url, this.options.transport, negotiateResponse, transferFormat);\n            }\n\n            this.transport!.onreceive = this.onreceive;\n            this.transport!.onclose = (e) => this.stopConnection(e);\n\n            // only change the state if we were connecting to not overwrite\n            // the state if the connection is already marked as Disconnected\n            this.changeState(ConnectionState.Connecting, ConnectionState.Connected);\n        } catch (e) {\n            this.logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\n            this.connectionState = ConnectionState.Disconnected;\n            this.transport = undefined;\n            throw e;\n        }\n    }\n\n    private async getNegotiationResponse(url: string): Promise<INegotiateResponse> {\n        let headers;\n        if (this.accessTokenFactory) {\n            const token = await this.accessTokenFactory();\n            if (token) {\n                headers = {\n                    [\"Authorization\"]: `Bearer ${token}`,\n                };\n            }\n        }\n\n        const negotiateUrl = this.resolveNegotiateUrl(url);\n        this.logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}`);\n        try {\n            const response = await this.httpClient.post(negotiateUrl, {\n                content: \"\",\n                headers,\n            });\n\n            if (response.statusCode !== 200) {\n                throw Error(`Unexpected status code returned from negotiate ${response.statusCode}`);\n            }\n\n            return JSON.parse(response.content as string) as INegotiateResponse;\n        } catch (e) {\n            this.logger.log(LogLevel.Error, \"Failed to complete negotiation with the server: \" + e);\n            throw e;\n        }\n    }\n\n    private createConnectUrl(url: string, connectionId: string | null | undefined) {\n        if (!connectionId) {\n            return url;\n        }\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionId}`;\n    }\n\n    private async createTransport(url: string, requestedTransport: HttpTransportType | ITransport | undefined, negotiateResponse: INegotiateResponse, requestedTransferFormat: TransferFormat): Promise<void> {\n        let connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);\n        if (this.isITransport(requestedTransport)) {\n            this.logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\n            this.transport = requestedTransport;\n            await this.transport.connect(connectUrl, requestedTransferFormat);\n\n            // only change the state if we were connecting to not overwrite\n            // the state if the connection is already marked as Disconnected\n            this.changeState(ConnectionState.Connecting, ConnectionState.Connected);\n            return;\n        }\n\n        const transports = negotiateResponse.availableTransports || [];\n        for (const endpoint of transports) {\n            this.connectionState = ConnectionState.Connecting;\n            const transport = this.resolveTransport(endpoint, requestedTransport, requestedTransferFormat);\n            if (typeof transport === \"number\") {\n                this.transport = this.constructTransport(transport);\n                if (!negotiateResponse.connectionId) {\n                    negotiateResponse = await this.getNegotiationResponse(url);\n                    connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);\n                }\n                try {\n                    await this.transport!.connect(connectUrl, requestedTransferFormat);\n                    this.changeState(ConnectionState.Connecting, ConnectionState.Connected);\n                    return;\n                } catch (ex) {\n                    this.logger.log(LogLevel.Error, `Failed to start the transport '${HttpTransportType[transport]}': ${ex}`);\n                    this.connectionState = ConnectionState.Disconnected;\n                    negotiateResponse.connectionId = undefined;\n                }\n            }\n        }\n\n        throw new Error(\"Unable to initialize any of the available transports.\");\n    }\n\n    private constructTransport(transport: HttpTransportType) {\n        switch (transport) {\n            case HttpTransportType.WebSockets:\n                return new WebSocketTransport(this.accessTokenFactory, this.logger, this.options.logMessageContent || false);\n            default:\n                throw new Error(`Unknown transport: ${transport}.`);\n        }\n    }\n\n    private resolveTransport(endpoint: IAvailableTransport, requestedTransport: HttpTransportType | undefined, requestedTransferFormat: TransferFormat): HttpTransportType | null {\n        const transport = HttpTransportType[endpoint.transport];\n        if (transport === null || transport === undefined) {\n            this.logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\n        } else {\n            const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\n            if (transportMatches(requestedTransport, transport)) {\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\n                    this.logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'`);\n                    return transport;\n                } else {\n                    this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\n                }\n            } else {\n                this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\n            }\n        }\n        return null;\n    }\n\n    private isITransport(transport: any): transport is ITransport {\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\n    }\n\n    private changeState(from: ConnectionState, to: ConnectionState): boolean {\n        if (this.connectionState === from) {\n            this.connectionState = to;\n            return true;\n        }\n        return false;\n    }\n\n    private stopConnection(error?: Error): void {\n        this.transport = undefined;\n\n        // If we have a stopError, it takes precedence over the error from the transport\n        error = this.stopError || error;\n\n        if (error) {\n            this.logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\n        } else {\n            this.logger.log(LogLevel.Information, \"Connection disconnected.\");\n        }\n\n        this.connectionState = ConnectionState.Disconnected;\n\n        if (this.onclose) {\n            this.onclose(error);\n        }\n    }\n\n    private resolveUrl(url: string): string {\n        // startsWith is not supported in IE\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\n            return url;\n        }\n        throw new Error(`Cannot resolve '${url}'.`);\n    }\n\n    private resolveNegotiateUrl(url: string): string {\n        const index = url.indexOf(\"?\");\n        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\n            negotiateUrl += \"/\";\n        }\n        negotiateUrl += \"negotiate\";\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\n        return negotiateUrl;\n    }\n}\n\nfunction transportMatches(requestedTransport: HttpTransportType | undefined, actualTransport: HttpTransportType) {\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\n}\n"]}